---
title: Hands-on with Weaviate
sidebar_position: 30
---

## Introduction

Recall Weaviate's key capabilities.
Construct a semantic search query string to retrieve relevant information.

:::warning TODO
Video here
:::

You have learned a lot already about vector searches. You have learned what vectors are, how they can represent meaning, and how vector searches can leverage these representations to perform similarity-based searches. 

In this lab, you will start to take that theory to practice and try vector searches in action by searching through our demo database of quiz questions and categories. You will learn how to use Weaviate to retrieve objects based on their similarity, using various query types such as an input text, vector, or object. In the process you will also begin to familiarize yourself with GraphQL which is the primary query language in Weaviate.

You will also compare vector search with keyword search to compare and contrast the two techniques, before learning how to combine the two techniques through the use of filters.

We will also touch on advanced techniques such as hybrid search.

### Vector search in action

![](https://media.istockphoto.com/id/1219473617/vector/young-male-character-writing-code-on-a-desktop-computer-working-from-home-millennials-at-work.jpg?s=612x612&w=is&k=20&c=roUA97RKbkKr1nTUf1snC9rbEXSTUH5obfDw9xFo-5g=)

For our first search, let's look for categories that best match our input query. The "Category" class in the Weaviate instance [DEMO INSTANCE LOCATION](http://example.com) is populated with categories that each question belongs to. 

The below has been set up so that it would retrieve the closest categories to the input query "Ground-breaking scientific discovery". Try running it yourself:

:::warning TODO
- Replace instance location ABOVE with actual instance
- Replace query ABOVE with actual query
- Pre-set QUERY here (show results when user hits GO)
- Should be something where the results don't have literal matches
:::

Note that the results are very much conceptually relevant even though they don't have much in the way of literal overlap with our query. This is exactly what we have been learning about - vector searches can identify related objects. What we have not yet seen however, is the syntax. So let's dive into that a little bit.

## GraphQL

![](https://devopedia.org/images/article/147/8496.1558526064.jpg)

Weaviate utilizes GraphQL as the query language for its searches. GraphQL is a very flexible and efficient query language built on graph data structures. 

Although much of the specific GraphQL syntax will be abstracted away if you use a Weaviate client library, it is very useful to know what GraphQL enables. So let's spend a little bit of time learning the basic syntax.

Each GraphQL query in Weaviate is structured like this:

```graphql
{
  <Function> {
    <Class> {
      <properties>
      _additional {
        <additional_properties>
      }
    }
  }
}
```

The query format begins with a `Function`, such as `Get` (to retrieve objects) and `Aggregate` (to retrieve metadata), as well as a `Class` denoting the data object collection. Notably, it then goes on to specify a set of `properties` as well as `additional_properties`, which determine the fields to be returned. 

You may notice from this that the data to be returned is not predetermined, unlike, for example, REST endpoints. This difference allows you to request only the data that you need from Weaviate, reducing over-fetching or under-fetching of data. 

## Search query examples

![](https://media.istockphoto.com/id/1124838925/vector/programming-code-application-window.jpg?s=612x612&w=is&k=20&c=-39O-FalRyZHGF5P5FFVEN17hXTLgkNyWHaZY9C-VbQ=)

Now let's construct a few GraphQL queries to search the `Question` class and retrieve objects using the `Get` function.

To begin, we wil inspect its schema to identify the right properties to query.

<details>
  <summary>Class schema</summary>

```json
{
    "classes": [
        {
            "class": "Question",
            "description": "A Jeopardy! question",
            "moduleConfig": {
                "text2vec-openai": {
                    "model": "ada",
                    "modelVersion": "002",
                    "type": "text",
                    "vectorizeClassName": true
                }
            },
            "properties": [
                {
                    "dataType": [
                        "text"
                    ],
                    "description": "Question asked to the contestant",
                    "moduleConfig": {
                        "text2vec-openai": {
                            "skip": false,
                            "vectorizePropertyName": false
                        }
                    },
                    "name": "question",
                    "tokenization": "word"
                },
                {
                    "dataType": [
                        "text"
                    ],
                    "description": "Answer provided by the contestant",
                    "moduleConfig": {
                        "text2vec-openai": {
                            "skip": false,
                            "vectorizePropertyName": false
                        }
                    },
                    "name": "answer",
                    "tokenization": "word"
                },
                //  Additional properties truncated for brevity
            ],
            //  Truncated for brevity
            "vectorIndexType": "hnsw",
            "vectorizer": "text2vec-openai"
        }
    ]
}
```

</details>

The class contains (among others) properties named "question" and "answer". We will query for these properties as doing so will give us enough detail to identify whether the query has identified appropriate objects.

### Retrieve objects

To retrieve objects in the `Question` class with their `question` and `answer` properties, the query would look like this:

```graphql
{
  Get {
    Question {
      question
      answer
    }
  }
}
```

Which returns a list of questions as below.

:::warning TODO
Show query results
:::

Note that this did not specify how many results to return. This can be specified as an argument in the context of the `Class` (`Question` in this case). The maximum number of objects to be returned can be specified as a `limit` argument as below:

```graphql
{
  Get {
    Question (limit: 2) {
      question
      answre
    }
  }
}
```

:::warning TODO
Show query results
:::

These 'arguments` are the other significant parts of constructing a GraphQL query. They allow you to provide additional information to Weaviate as we did here with the upper limit of objects.

Now that you're familiar with a basic GraphQL syntax, let's try vector searches next.

### Perform a vector (nearText) search

Let's reproduce the demo vector search above where we searched for `Question` objects similar to 'QUERY ENTRY'.

This is achieved in Weaviate with a `nearText` search, and can be carried out with the below syntax: 

```graphql
{
  Get {
    Question (
      limit: 1
      nearText: {
        concepts: ["A pivotal point in world history"],
        distance: 0.6 
      }
    ) {
      question answer
    }
  }
}
```

Which produces 

```json
{
  "data": {
    "Get": {
      "Question": [
        {
          "answer": "discovery of the New World",
          "question": "This world-changing event was first announced in a Barcelona banquet hall in April 1493"
        }
      ]
    }
  }
}
```

## Weaviate client libraries

![](https://cdn.hackr.io/uploads/posts/large/1611758548dzkO7CszxO.png)

You can communicate with Weaviate with the available [client libraries](/developers/weaviate/client-libraries/index.md) (currently available for `Python`, `JavaScript`, `Java` and `Go`) or directly with the [RESTful API](/developers/weaviate/api/rest/index.md) and the [GraphQL API](/developers/weaviate/api/graphql/index.md).

import ClientCapabilitiesOverview from '/_includes/client.capabilities.mdx'

<ClientCapabilitiesOverview />

Install your preferred client by following the relevant instructions below:

import CodeClientInstall from '/_includes/code/quickstart.clients.install.mdx';

<CodeClientInstall />

Next, we will take you end-to-end with Weaviate, all the way to making vector queries already!

## Review

:::warning TODO
Video here
:::

### Review exercise

Can you describe, in your own sentence, XXX?

:::warning TODO
Input box for user to put answer in and get back a similarity score & our definition?
??
:::

### Key takeaways

:::info
Add summary
:::