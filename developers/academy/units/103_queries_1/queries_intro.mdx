---
title: Querying Weaviate
sidebar_position: 10
---

## GraphQL and REST APIs in Weaviate

:::warning TODO
Intro video here
:::

Weaviate uses both REST and GraphQL API interfaces for its users. This section will explain the differences between the two and how they are used in Weaviate.

### Introduction to REST and GraphQL

![](https://nordicapis.com/wp-content/uploads/REST-vs-GraphQL.png)

REST and GraphQL are two different approaches to building APIs. REST is a widely used approach to building APIs, while GraphQL is a relatively new approach that is gaining popularity.

REST is an acronym for REpresentational State Transfer. A REST API provides multiple endpoints, each with its own URL, that can be used to interact with the API. The endpoints are organized into a hierarchy, with each endpoint representing a resource. The client can then request information about these resources by sending a request to the server.

GraphQL is a query language for APIs. First released by Facebook in 2015, it is now maintained by the GraphQL Foundation. GraphQL is a specification for a query language that can be used to request information from a server. GraphQL is a strongly typed language, which means that the client must specify the type of data that it wants to receive.

The two approaches are complementary and so Weaviate uses both to provide a rich API for its users.

#### Uses in Weaviate

In Weaviate, the REST API is used to interact with Weaviate for CRUD operations and to obtain metadata about the database. 

The GraphQL API is used to interact with Weaviate for data searches. More specifically, it can be used to retrieve data objects, aggregate information, and explore vector spaces.

In this module, we will focus on various strategies to query Weaviate using GraphQL to retrieve information.

### Why GraphQL for data retrieval

![](https://kinsta.com/wp-content/uploads/2022/09/graphql.png)

One of the key benefits of GraphQL is that it allows the user to specify the exact data that they want to retrieve. This means that the user can request only the data that they need, reducing over-fetching or under-fetching of data.

Let's review the fundamental syntax of GraphQL in Weaviate.

```graphql
{
  <Function> {
    <Class> {
      <properties>
    }
  }
}
```

You can see that a Weaviate GraphQL query contains multiple components. If you were to query a database of quiz objects, the fields in the above query would be as follows:

* `<Function>`: The function that you want to use, such as `Get`, `Aggregate`, or `Explore`.
* `<Class>`: The class that you want to retrieve data from, such as `Question` or `Category`.
* `<properties>`: The properties that you want to retrieve, such as `question`, `answer` or `value`.

Each field can also accept arguments, such as `limit` to limit the number of objects to be returned, or `where` to apply a filter. 

This specificity may seem challenging at first. However, it is a powerful feature that allows you to build highly customized queries, and to retrieve only the data that you need. 

It is also highly efficient, as what may have taken multiple requests in a REST API can be done in a single GraphQL query.

### GraphQL and Weaviate clients

![](https://cdn.hackr.io/uploads/posts/large/1611758548dzkO7CszxO.png)

Weaviate offers client libraries for multiple widely used programming languages in Python, JavaScript, Java, and Go. These client libraries simplify the use of GraphQL syntax by allowing interaction with Weaviate using constructs of the respective native programming language.

The client libraries also give the option to use raw GraphQL queries directly.

So, the learning material will refer to use raw GraphQL queries to deepen your understanding and increase your comfort level with this crucial topic. However, we will provide code examples using the client libraries as we go.

Where available, each code example will be shown in tabs to allow you to switch between the raw GraphQL query and the client library code. For example, the following code example is shown in both raw GraphQL and Python client library code.

<!-- Delete these imports if already imported in the file -->
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="languages">
<TabItem value="graphql" label="GraphQL">

```graphql
{
  Get {
    Question (limit: 1) {
      question
      answer
    }
  }
}
```

</TabItem>
<TabItem value="py" label="Python">

```python
<!-- Python code goes here -->
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js
<!-- JavaScript code goes here -->
```

</TabItem>
<TabItem value="go" label="Go">

```go
<!-- Go code goes here -->
```

</TabItem>
<TabItem value="java" label="Java">

```java
<!-- Java code goes here -->
```

</TabItem>
<TabItem value="curl" label="Curl">

```bash
<!-- Curl code goes here -->
```

</TabItem>
</Tabs>

All Weaviate clients can also execute raw GraphQL queries. The following code examples show how each client can be used to execute a raw GraphQL query.

<!-- TODO - modularize these into separate files -->

<Tabs groupId="languages">
<TabItem value="py" label="Python">

```python
<!-- Python code goes here -->
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js
<!-- JavaScript code goes here -->
```

</TabItem>
<TabItem value="go" label="Go">

```go
<!-- Go code goes here -->
```

</TabItem>
<TabItem value="java" label="Java">

```java
<!-- Java code goes here -->
```

</TabItem>
<TabItem value="curl" label="Curl">

```bash
<!-- Curl code goes here -->
```

</TabItem>
</Tabs>

:::info GraphQL in requests

We note that each GraphQL query which is sent to the endpoint takes the below form. The GraphQL query is provided as the value to the `query` key in the JSON payload.

```json
{
    "query": "{ # GRAPHQL QUERY }"
}
```

For our purposes, however, we will only need to construct the query body and pass it to the GraphQL console, or to an appropriate client as the raw query.

:::

<Quiz questions={varName} />

## GraphQL functions

:::warning TODO
Intro video here
:::

The available GraphQL functions in Weaviate are `Get`, `Aggregate` and `Explore`. These three functions are used to `Get` objects, `Aggregate` information and `Explore` vector spaces. 

Let's review each one briefly, before we learn about them in detail in the following sections.

### `Get` objects

You might have seen this function in the earlier, introductory, unit. The `Get` function is used in Weaviate to retrieve data objects. For many use cases, `Get` will be the most common type of query function used in Weaviate.

Try the following query, for example:

```graphql
{
  Get {
    Question (limit: 1) {
      question
      answer
    }
  }
}
```

This query applies the `Get` function on the `Question` class, with an argument `limit: 1` which limits the number of returned objects to a maximum of 1. 

It should produce a response look like the following:

```json
{
  "data": {
    "Get": {
      "Question": [
        {
          "answer": "Amazon.com",
          "question": "On July 16, 1995 this company made its first sale, a science textbook"
        }
      ]
    }
  }
}
```

You can see that the response includes a data object from the `Question` class, and values of its `question` and `answer` properties. 

:::info Formatting in GraphQL queries
For the most part GraphQL is very flexible in terms of formatting, such that [whitespaces](https://spec.graphql.org/October2021/#sec-White-Space) and [commas](https://spec.graphql.org/October2021/#sec-Insignificant-Commas) are typically insignificant. For instance, the above query could have been written as the following:
```graphql
{Get{Question(limit:1){question answer}}}
```

Or even (notice the comma):
```graphql
{Get{Question(limit:1){question,answer}}}
```

Do note that, however, names in GraphQL [are case-sensitive](https://spec.graphql.org/October2021/#sec-Names), so `Get` and `Question` are different from `get` and `question`.
:::

### `Aggregate` information

Whereas `Get` returns objects, `Aggregate` returns summary statistics or aggregates from the result set. 

This allows retrieval of calculations on a set of values to return a single value, or summary value produced based on groups of outputs. 

For example, the following query will produce a number of statistical values in relation to the `value` property in the `Question` class.

```graphql
{
  Aggregate {
    Question (limit: 100) {
      value {
        minimum
        maximum
        mean
      }
    }
  }
}
```

It should produce a response that looks like the following:

```json
{
  "data": {
    "Aggregate": {
      "Question": [
        {
          "value": {
            "maximum": 10000,
            "mean": 632.41,
            "minimum": 0
          }
        }
      ]
    }
  }
}
```

### `Explore` vector spaces

`Explore` is a powerful function in Weaviate that allows you to navigate the entire vector space. 

This means that you can use `Explore` to find objects that are similar to a given object or vector, regardless of the class of the object. As such, `Explore` is very useful when you may not be sure of what class to search for.

In relation to our Quiz dataset, a query using the `Explore` function would return a set of objects from both the `Question` and `Category` classes.

We will explore the `Explore` function in more detail in a following unit.

<Quiz questions={varName} />

## GraphQL arguments

:::warning TODO
Intro video here
:::

You've already seen that GraphQL queries can take arguments such as `limit`. In this section, we'll take a closer look at the arguments that are available for each function. 

### Argument syntax in GraphQL

Arguments are provided in GraphQL as a comma-separated list of key-value pairs, enclosed in parentheses. Recall the following example for the `Get` function, where we provided the limit argument:

```graphql
{
  Get {
    Question (limit: 1) {
      question
      answer
    }
  }
}
```

We can introduce additional arguments by adding them. Let's take a look at examples of types of arguments which can be added to queries.

### Vector search parameters

As you know, Weaviate can search for objects based on their proximity to a vector. This vector can be specified with a variety of parameters, including `nearVector`, `nearObject`, or `nearText` for example. 

These parameters are provided to Weaviate as arguments to the class (e.g. `Get`) in the GraphQL query. 

For example, the below query will add a `nearVector` parameter:

```graphql
{
  Get {
    Question (
      limit: 1,
      nearVector: {vector: <VECTOR>}
      ) {
      question
      answer
    }
  }
}

print(json.dumps(response, indent=2))
```

When a vector for "unusual animals" is used as a the input, the query returns:

```json
{
  "data": {
    "Get": {
      "Question": [
        {
          "answer": "raccoons",
          "question": "The crab-eating one of these masked animals eats fish, fruit & frogs, too"
        }
      ]
    }
  }
}
```

Vector search parameters can also be used with the `Aggregate` and `Explore` functions. They are key inputs that specify the way in which the vector space is searched. We will review these in more detail in a following section of this unit.

### Filters

Filters are used to limit the results of a query to a subset of the data. For example, you might wish to limit the search to a particular category, or perhaps to those questions that have a value greater than a certain threshold.

So, we could modify the above query to only search for questions with a value greater than 100:

```graphql
{
  Get {
    Question (
      limit: 1,
      nearVector: {vector: <VECTOR>},
      where: {
        path: ["value"],
        operator: GreaterThan,
        valueInt: 100,
      }
      ) {
      question
      answer
    }
  }
}
```

The additional `where` filter limits the results here to questions where the `value` property is greater than 100. Our top result is now:

```json
{
  "data": {
    "Get": {
      "Question": [
        {
          "answer": "Zebra",
          "question": "It's the striped African mammal with whom the insect seen here shares part of its name"
        }
      ]
    }
  }
}
```

Filters are available for all functions, and are an important part of your search strategy. We will review these in more detail in a following section of this unit.

### Additional properties

Each GraphQL query can also be extended to request additional properties. These include information such as the `id` or `vector` of the object or a `certainty` value of the search result. 

Weaviate's GraphQL syntax includes a reserved `_additional` field which can be used to request additional properties. The following will request the object's ID along with the `question` and `answer` properties:

```graphql
{
  Get {
    Question (limit: 1) {
      question
      answer
      _additional {
        id
      }
    }
  }
}
```

And it will return:

```json
{
  "data": {
    "Get": {
      "Question": [
        {
          "_additional": {
            "id": "0000d624-976b-5c43-abf3-ec9491ddb1bc"
          },
          "answer": "Amazon.com",
          "question": "On July 16, 1995 this company made its first sale, a science textbook"
        }
      ]
    }
  }
}
```

Additional properties are extremely valuable. They can help to retrieve object IDs or vectors for re-use, or review search results based on their certainty. We will also review these in more detail in a following section of this unit.

<Quiz questions={varName} />

## Review

:::warning TODO
Video here
:::

### Review exercise

Can you describe, in your own sentence, XXX?

:::warning TODO
Input box for user to put answer in and get back a similarity score & our definition?
??
:::

### Key takeaways

:::info
Add summary
:::

import Quiz from '/src/components/Academy/quiz.js'
const varName = [{
  questionText: 'questionText',
  answerOptions: [
    {
      answerText: 'answerOne',
      isCorrect: false,
      feedback: 'feedbackOne',
    },
    {
      answerText: 'answerTwo',
      isCorrect: false,
      feedback: 'feedbackTwo',
    },
    {
      answerText: 'answerThree',
      isCorrect: false,
      feedback: 'feedbackThree',
    },
  ]
}];