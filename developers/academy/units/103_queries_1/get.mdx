---
title: Retrieving objects with Get{}
sidebar_position: 20
---

## About `Get` queries

:::warning TODO
Intro video here
:::

In many use cases, retrieving objects from a Weaviate instance may be the most common operation. 

For example, a user may want to retrieve a list of passages most closely related to the input query, or they may wish to retrieve a list of images which are most similar to another image. It may even be possible to retrieve a set of images that best match a given passage.

In Weaviate, these operations are performed using the `Get` function.

### `Get` function syntax

![](../../tmp_images/a_person_holding_a_magnifying_glass_at_computer_screen_with_code_0_short.png)

The syntax of a `Get` function is as follows:

```graphql
{
  Get {
    <Class> (
      <arguments>
    ) {
      <properties>
    }
  }
}
```

To review the syntax:

- The `Class` field specifies the name of the class of objects to be retrieved. 
- The `arguments` argument specifies the search criteria to be used to retrieve the objects. 
- The `properties` argument specifies the properties of the objects to be retrieved, including any `_additional` properties.

### Class-based fields: `Class` and `properties`

From this context, the `Class` and `properties` must correspond to collections of objects that have been defined in the Weaviate schema.

In other words, the `Class` must be the name of a class that has been defined in the Weaviate schema, and the `properties` must be the names of properties that have been defined for that class.

Let us review an example schema to illustrate this point. A schema might contain definitions of object collections (i.e. classes) as follows (truncated for readability):

import ExampleSchema from '/developers/academy/snippets/example_schema.mdx';

<ExampleSchema/>

The schema contains two classes: `Category` and `Question`. The `Category` class contains the property `title`, and the `Question` class contains properties: `question`, `answer`, `value`, and `hasCategory`.

So, a query retrieving objects from the `Category` class will specify can specify the `title` property, and a query retrieving objects from the `Question` class can specify any of its properties such as `question`, `answer`, `value`, and `hasCategory`.

### Function-based fields: `arguments`

The `arguments` field specifies the search criteria to be used to retrieve the objects. This may be to specify criteria for a vector search, to specify a filter to be applied to the results, or to provide additional constraints such as the number of limits to be returned. 

The `arguments` field is optional, and if it is not specified, then all objects of the specified class will be returned.

<Quiz questions={varName} />

## `Get` queries in practice

:::warning TODO
Intro video here
:::

Now that we've read about the syntax of the `Get` function, let's see it in action.

### Standalone `Get` queries

It is possible to query Weaviate with the `Get` function without any vector search parameters.

```graphql
{
  Get {
    Question (
      limit: 2
    ) {
      question 
      answer 
    }
  }
}
```

In this case, Weaviate will return two objects due to the `limit:2` argument. Without this limit, Weaviate would return a maximum number according to its configuration.

As this does not apply any user-specific criteria to the search, the results will not be very useful. However, this may be a viable method for "sanity" checks, such as checking that you can connect to a Weaviate instance, or that at least some objects have been imported successfully.

### `Get` with `additional` properties

In this example, we've built on the previous example by adding the `_additional` field to the `Get` query. This field allows us to retrieve additional properties that are not defined in the schema, such as the `vector` and `id` properties, for the object vector and the UUID respectively.

```graphql
{
  Get {
    Question (
      limit: 2
    ) {
      question 
      answer 
      _additional {
        vector
        id
      }
    }
  }
}
```

Note that the returned vector in many cases will be a very long list of numbers. 

While inspecting the individual values of the vector may have limited use, it may be useful to review the length of the vector to ensure that it is as you expected, or to retrieve the vector for re-use.

### `Get` with `nearText`

The `nearText` parameter specifies the a text input which will be the basis for the vector search. 

This parameter is passed as an argument in the GraphQL query like below, where the `concepts` argument specifies the text input to be used for the vector search.

```graphql
{
  Get {
    Question (
      limit: 3
      nearText: {
        concepts: ["Seafaring technology from Scandanavia."],
      }
    ) {
      question 
      answer 
      _additional {
        distance
        id
      }
    }
  }
}
```

This should produce a result like the following:

<details>
  <summary>Query results</summary>

```json
{
  "data": {
    "Get": {
      "Question": [
        {
          "_additional": {
            "distance": 0.14927602,
            "id": "5d9d5c8d-13e7-5791-b2f9-3724a1a1d301"
          },
          "answer": "Oslo",
          "question": "1,200-year-old Viking ships are on display at the Vikingskiphuset in this Norwegian capital"
        },
        {
          "_additional": {
            "distance": 0.1706214,
            "id": "67e4c36d-2970-5ffd-af81-d7917f58de01"
          },
          "answer": "Roald Amundsen",
          "question": "Using a herring boat, this Norwegian became the first to navigate the Northwest Passage in 1906"
        },
        {
          "_additional": {
            "distance": 0.17154193,
            "id": "5edd4acb-9860-5c84-b7b7-90e757aa8c1e"
          },
          "answer": "Eric the Red",
          "question": "In 982 he sailed from Iceland to Greenland with his household & livestock"
        }
      ]
    }
  }
}
```

</details>

Under the hood, what is happening is that Weaviate is converting the input to a vector, and performing a vector search. The results are then returned in order of their similarity to the input vector.

You will also notice that the query included the `distance` property in the `_additional` field. This represents the degree of similarity (or, in this case, the *difference*) between the input vector and the vector of the object. The value is a number between 0 and 1, where 0 means the two objects are identical, and 1 orthogonal.

:::info `nearText` parameter requires a vectorizer!
Because text object must be converted to a vector before it can be used in a vector search, the `nearText` parameter is only available when a vectorizer module has been specified for the class.
:::

#### Adding a distance threshold

It is important to understand that, unlike a lexical search, a vector search does not by itself exclude any results.

As described above, a vector search returns a ranked set of objects based on degrees of similarity on a scale of 0 to 1. If you wish to retrieve a limited set of results, a similarity threshold must be specified in the query so that objects that are more dissimilar can be rejected. 

In Weaviate, you can do this by specifying a `distance` threshold like so:

```graphql
{
  Get {
    Question (
      nearText: {
        concepts: ["Seafaring technology from Scandanavia."],
        distance: 0.15
      }
    ) {
      question 
      answer 
      _additional {
        distance
        id
      }
    }
  }
}
```

This will only retrieve objects which are within a cosine distance of 0.15, limiting the results to the below. Note that due to the distance threshold being provided, Weaviate only returns one object even though the `limit` argument has been removed.

<details>
  <summary>Query results</summary>

```json
{
  "data": {
    "Get": {
      "Question": [
        {
          "_additional": {
            "distance": 0.1492011,
            "id": "5d9d5c8d-13e7-5791-b2f9-3724a1a1d301"
          },
          "answer": "Oslo",
          "question": "1,200-year-old Viking ships are on display at the Vikingskiphuset in this Norwegian capital"
        }
      ]
    }
  }
}
```

</details>

:::note Exercise: Threshold distances
Try changing the query text, and `distance` threshold to higher, or lower, values to see what happens. How many results do you get back? How many of the results seem "relevant"?
:::

### `Get` with a filter

Next, we will extend the query again by introducing a filter. A filter is a way to specify additional criteria to be applied to the results of the vector search. It is analogous to the `WHERE` clause in a SQL query, and in fact the argument in Weaviate is also called `where`.

Below, we extend our query again to now include a `where` argument, specifying that the `question` property of the object must contain the text `sail`.

```graphql
{
  Get {
    Question (
      limit: 2
      nearText: {
        concepts: ["Seafaring technology from Scandanavia."],
      }
      where: {
        path: ["question"],    
        operator: Like,  
        valueText: "*sail*"
      }      
    ) {
      question 
      answer 
      _additional {
        distance
        id
      }
    }
  }
}
```

This should produce a result like the following:

<details>
  <summary>Query results</summary>

```json
{
  "data": {
    "Get": {
      "Question": [
        {
          "_additional": {
            "distance": 0.17154193,
            "id": "5edd4acb-9860-5c84-b7b7-90e757aa8c1e"
          },
          "answer": "Eric the Red",
          "question": "In 982 he sailed from Iceland to Greenland with his household & livestock"
        },
        {
          "_additional": {
            "distance": 0.18194813,
            "id": "ba9c9bc6-17fc-5fde-b8c2-4801829dbdbd"
          },
          "answer": "engines",
          "question": "France II, at 419 feet the largest merchant sailing ship ever built, also had 2 of these to back up the sails"
        },
        {
          "_additional": {
            "distance": 0.18973523,
            "id": "135fd0ad-66bf-5974-b6e6-ac79793df469"
          },
          "answer": "a clipper ship",
          "question": "The \"Baltimore\" type of this sailing ship originated in the Chesapeake Bay region in the 1800s"
        }
      ]
    }
  }
}
```

</details>

Refer to the results above, and observe how the results have changed. The first two entries from the earlier result set have been removed as they do not contain the text `sail` in the `question` property. 

This approach of combining a vector search with a filter is a powerful way to find objects that are similar to a given input, but also meet additional criteria as you see. And while filtering may remove some objects which might otherwise be "closer" to the query vector than the remaining ones, it provides a powerful strategy to find the most relevant objects by removing false positive.

<Quiz questions={varName} />

### `Get` with cross-references

And before we wrap up this section, let's take a look at how to perform a `Get` query with cross-references. While we have not yet covered cross-references in detail in this unit, for now it is sufficient to know that they are a way to connect objects to each other.

In the example below, we will perform a `Get` query on the `Question` class, but this time we will include the `hasCategory` property in the query. This property is a cross-reference to the `Category` class, and will be used to return the category of each question.

```graphql
{
  Get {
    Question (
      limit: 1
      nearText: {
        concepts: ["Seafaring technology from Scandanavia."],
      }   
    ) {
      question 
      answer 
      hasCategory {
        ... on Category {
          title
          _additional {
            id
          }            
        }
      }      
      _additional {
        distance
        id
      }
    }
  }
}
```

This produces a result like the following:

<details>
  <summary>Query results</summary>

```json
{
  "data": {
    "Get": {
      "Question": [
        {
          "_additional": {
            "distance": 0.14927602,
            "id": "5d9d5c8d-13e7-5791-b2f9-3724a1a1d301"
          },
          "answer": "Oslo",
          "hasCategory": [
            {
              "_additional": {
                "id": "fec50326-dfa1-53c9-90e8-63d0240bd933"
              },
              "title": "MUSEUMS"
            }
          ],
          "question": "1,200-year-old Viking ships are on display at the Vikingskiphuset in this Norwegian capital"
        }
      ]
    }
  }
}
```

</details>

Where the `hasCategory` property is now an array of objects, containing objects of type `Category` that the Question is related to and their requested properties. The `title` property of the `Category` class is returned as well, and the `_additional` field contains the `id` of the category. 

Cross-references provide you with a great deal of flexibility and power in your data model, and are a great way to connect objects to each other. We will cover them in more detail in our unit on schemas.

:::info `...` pattern
You may have noticed the `... on Category` pattern in the above query. This syntax is called a "fragment" in GraphQL terms. Populated this way, the fragment specifies that the `hasCategory` property is of type `Category`, and that the results should be returned as such.
:::

<Quiz questions={varName} />

## Review

:::warning TODO
Video here
:::

### Review exercise

Can you describe, in your own sentence, XXX?

:::warning TODO
Input box for user to put answer in and get back a similarity score & our definition?
??
:::

### Key takeaways

:::info
Add summary
:::

import Quiz from '/src/components/Academy/quiz.js'
const varName = [{
  questionText: 'questionText',
  answerOptions: [
    {
      answerText: 'answerOne',
      isCorrect: false,
      feedback: 'feedbackOne',
    },
    {
      answerText: 'answerTwo',
      isCorrect: false,
      feedback: 'feedbackTwo',
    },
    {
      answerText: 'answerThree',
      isCorrect: false,
      feedback: 'feedbackThree',
    },
  ]
}];