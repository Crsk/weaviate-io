---
title: More about arguments
sidebar_position: 50
---

import imageUrl from '../../tmp_images/academy_placeholder.jpg';

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;Available operators

<img src={imageUrl} alt="Image alt" width="75%"/>

You have already seen some arguments that are available in Weaviate, such as `limit`, or `nearVector`.

In fact, arguments in Weaviate are wide-ranging. Take a look at just some of the available operators.

### <i class="fa-solid fa-chalkboard"></i>&nbsp;&nbsp;Available arguments

Some of the available arguments are:

#### Vector search

- `nearObject`: For searching based on a particular object's vector.
- `nearVector`: For searching based on a specified vector.
- `bm25`: For performing BM25 searches.
- `hybrid`: For performing hybrid searches.
- `ask`: To retrieve a specific answer based on stored object data.

#### Filtering

- `where`: Apply a Boolean filter from which your search will be carried out.
- `limit`: Restrict the maximum objects to be retrieved.
- `sort`: For sorting non-vector search results.
- `offset`: For pagination of vector search results.

(and more!)

But we don't need to cover them all at this moment. For now, let's explore a few more of the most commonly used, powerful arguments.

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;Filter data with `where`

<img src={imageUrl} alt="Image alt" width="75%"/>

A filter is a way to specify additional criteria to be applied to the results of the vector search. It is analogous to the `WHERE` clause in a SQL query, and in fact the argument in Weaviate is also called `where`.

### <i class="fa-solid fa-code"></i>&nbsp;&nbsp;Single operand example

Below, we extend our query again to now include a `where` argument, specifying that the `question` property of the object must contain the text `sail`.

```graphql
{
  Get {
    JeopardyQuestion (
      limit: 2
      nearText: {
        concepts: ["Seafaring technology from Scandanavia."],
      }
      where: {
        path: ["question"],    
        operator: Like,  
        valueText: "*sail*"
      }      
    ) {
      question 
      answer 
      _additional {
        distance
        id
      }
    }
  }
}
```

This should produce a result like the following:

<details>
  <summary><i class="fa-solid fa-radar"></i> See the JSON response</summary>

```json
{
  "data": {
    "Get": {
      "JeopardyQuestion": [
        {
          "_additional": {
            "distance": 0.17154193,
            "id": "5edd4acb-9860-5c84-b7b7-90e757aa8c1e"
          },
          "answer": "Eric the Red",
          "question": "In 982 he sailed from Iceland to Greenland with his household & livestock"
        },
        {
          "_additional": {
            "distance": 0.18194813,
            "id": "ba9c9bc6-17fc-5fde-b8c2-4801829dbdbd"
          },
          "answer": "engines",
          "question": "France II, at 419 feet the largest merchant sailing ship ever built, also had 2 of these to back up the sails"
        },
        {
          "_additional": {
            "distance": 0.18973523,
            "id": "135fd0ad-66bf-5974-b6e6-ac79793df469"
          },
          "answer": "a clipper ship",
          "question": "The \"Baltimore\" type of this sailing ship originated in the Chesapeake Bay region in the 1800s"
        }
      ]
    }
  }
}
```

</details>

Refer to the results above, and observe how the results have changed. The first two entries from the earlier result set have been removed as they do not contain the text `sail` in the `question` property. 

This approach of combining a vector search with a filter is a powerful way to find objects that are similar to a given input, but also meet additional criteria as you see. And while filtering may remove some objects which might otherwise be "closer" to the query vector than the remaining ones, it provides a powerful strategy to find the most relevant objects by removing false positive.

<Quiz questions={varName} />

So, we could modify the above query to only search for questions with a value greater than 100:

```graphql
{
  Get {
    JeopardyQuestion (
      limit: 1,
      nearVector: {vector: <VECTOR>},
      where: {
        path: ["value"],
        operator: GreaterThan,
        valueInt: 100,
      }
      ) {
      question
      answer
    }
  }
}
```

The additional `where` filter limits the results here to questions where the `value` property is greater than 100. Our top result is now:

```json
{
  "data": {
    "Get": {
      "JeopardyQuestion": [
        {
          "answer": "Zebra",
          "question": "It's the striped African mammal with whom the insect seen here shares part of its name"
        }
      ]
    }
  }
}
```

### <i class="fa-solid fa-code"></i>&nbsp;&nbsp;Multiple operands example



### <i class="fa-solid fa-code"></i>&nbsp;&nbsp;`Aggreagte` with `where`


Filters work similarly with `Aggregate` queries as they do with `Get` queries, providing you with a way to limit the results of your query. 

To identify how many questions have a value of over 600, a `where` filter can be constructed as shown below:

```graphql
{
  Aggregate {
    JeopardyQuestion (
      nearText: {
        concepts: ["Seafaring technology from Scandanavia."],
        distance: 0.2
      }
      where: {
          path: ["value"],
          operator: GreaterThan,
          valueInt: 600,
      }        
      ) {
      meta {
        count
      }
    }
  }
}
```

Which reduces the result set by filtering them by the question's `value` property.

<details>
  <summary><i class="fa-solid fa-radar"></i> See the JSON response</summary>

```json
{
  "data": {
    "Aggregate": {
      "JeopardyQuestion": [
        {
          "meta": {
            "count": 27
          }
        }
      ]
    }
  }
}
```

</details>

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;Distance thresholds

As you saw previously, vector search evaluate objects based on degrees of similarity, and as a result does not exclude any of the results.

Accordingly, it is desirable to limit the search space using a `limit` argument or based on distance. 

As you have seen before, the `limit` argument specifies the number of results to be retrieved. On the other hand, a threshold value such as `distance` or `certainty` specify the maximum distance (or, looked from the other direction, minimum similarity) required for objects being retrieved.

### <i class="fa-solid fa-code"></i>&nbsp;&nbsp;Examples

Specifying a `distance` threshold can be done like so:

```graphql
{
  Get {
    JeopardyQuestion (
      nearText: {
        concepts: ["Seafaring technology from Scandanavia."],
        distance: 0.15
      }
    ) {
      question 
      answer 
      _additional {
        distance
        id
      }
    }
  }
}
```

Think about how you expect the results to look before viewing the expected JSON output.

<details>
  <summary><i class="fa-solid fa-radar"></i> See the JSON response</summary>

```json
{
  "data": {
    "Get": {
      "JeopardyQuestion": [
        {
          "_additional": {
            "distance": 0.1492011,
            "id": "5d9d5c8d-13e7-5791-b2f9-3724a1a1d301"
          },
          "answer": "Oslo",
          "question": "1,200-year-old Viking ships are on display at the Vikingskiphuset in this Norwegian capital"
        }
      ]
    }
  }
}
```

</details>

:::note Exercise: Threshold distances
Try changing the query text, and `distance` threshold to higher, or lower, values to see what happens. How many results do you get back? How many of the results seem "relevant"?
:::

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;Pagination

Pagination can be used to retrieve latter parts of a results set; for example results 

### <i class="fa-solid fa-code"></i>&nbsp;&nbsp;`nearVector` with pagination

### <i class="fa-solid fa-chalkboard"></i>&nbsp;&nbsp;Practical considerations

Pagination is tied to a search. Accordingly, pagination results are retrieved by obtaining search results and then discarding those results ahead of the `offset`. This can make pagination resource-intensive. 

For use-cases that require high pagination, we refer you to our [documentation on this topic](/developers/weaviate/api/graphql/filters.md#performance-and-resource-considerations--limitations).

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;Review

:::warning TODO
Video here
:::

### <i class="fa-solid fa-pen-to-square"></i>&nbsp;&nbsp;Review exercise

Can you describe, in your own sentence, XXX?

:::warning TODO
Input box for user to put answer in and get back a similarity score & our definition?
??
:::

### <i class="fa-solid fa-lightbulb-on"></i>&nbsp;&nbsp;Key takeaways

:::info
Add summary
:::

import Quiz from '/src/components/Academy/quiz.js'
const varName = [{
  questionText: 'questionText',
  answerOptions: [
    {
      answerText: 'answerOne',
      isCorrect: false,
      feedback: 'feedbackOne',
    },
    {
      answerText: 'answerTwo',
      isCorrect: false,
      feedback: 'feedbackTwo',
    },
    {
      answerText: 'answerThree',
      isCorrect: false,
      feedback: 'feedbackThree',
    },
  ]
}];