---
title: Aggregate{} the result set
sidebar_position: 30
---

import imageUrl from '../../tmp_images/academy_placeholder.jpg';

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;About `Aggregate` queries

<img src={imageUrl} alt="Image alt" width="75%"/>

Now that you have seen how to retrieve individual objects with `Get` queries, let's take a look at how to compile information from multiple objects with `Aggregate` queries.

This is a powerful feature that allows you to combine information from multiple objects into a single result, whether it be data or metadata about those objects.

Using `Aggregate` queries is a great way to get a quick overview of your data, and can be used to create a variety of useful reports.

### <i class="fa-solid fa-chalkboard"></i>&nbsp;&nbsp;`Aggregate` function syntax

![](../../tmp_images/a_person_holding_a_magnifying_glass_at_computer_screen_with_code_0_short.jpg)

While the overall structure of `Aggregate` queries is similar to `Get` queries, there are some important differences as the queries relate to sets of results. The syntax for `Aggregate` queries is as follows:

```graphql
{
  Aggregate (groupBy:[<property>]) {  # `groupBy`: optional argument
    groupedBy {  # requires `groupBy` argument
        path
        value
    }
    meta {  # optional
      count
    }
    <Class> (
      <arguments>
    ) {
      <properties>
    }
  }
}
```

You will notice the presence of the `groupBy` argument, This is an optional argument that can be used to group results of the query. The `Aggregate` function can also return metadata about the results, such as the number of results in each group.

Additionally, available properties differ according to data types of the property being queried. For example, the available properties for a `String` property are different from those for an `Integer` property or a cross-reference.

Now let's learn by trying out some `Aggregate` queries.

As a reminder, our objects include the following schema:

<details>
  <summary>See relevant schema</summary>

import ShortSchema from './_snippets/academy.queries.schema.short.mdx';

<ShortSchema/>

</details>

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;Standalone `Aggregate` queries

As we did with `Get` queries, let's begin to look at simple examples of `Aggregate` queries. 

### <i class="fa-solid fa-code"></i>&nbsp;&nbsp;Example

Take a look at the below query:

```graphql
{
  Aggregate {
    JeopardyQuestion {
      meta {
        count
      }
    }
  }
}
```

What do you expect back?

:::note Try it out yourself!
SOME WAY OF TRYING THIS OUT
:::

This should return something like the below:

<details>
  <summary><i class="fa-solid fa-radar"></i> See the JSON response</summary>

```json
{
  "data": {
    "Aggregate": {
      "Question": [
        {
          "meta": {
            "count": 10000
          }
        }
      ]
    }
  }
}
```

</details>

### <i class="fa-solid fa-chalkboard"></i>&nbsp;&nbsp;`meta` property

Note that in our `Aggregate` query we specified a sub-property `count` under the requested property `meta`. This is a key difference between `Aggregate` and `Get` queries. 

In `Get` queries, we directly specify a property as the query returns individual objects according to our search criteria. On the other hand, an `Aggregate` query returns a set of results. Accordingly, we must specify a sub-property which can reflect some aspect of the entire set of results, such as the number of entries here.

The `meta` property is available for all data types, and can be used with the `count` sub-property to return the number of retrieved objects. 

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;`Aggregate` with `groupBy`

So far, we have seen how to use `Aggregate` queries to retrieve information relating one set of results. But this can be extended to retrieve information from multiple, subsets of results. This is done by using the `groupBy` argument.

### <i class="fa-solid fa-code"></i>&nbsp;&nbsp;Example

For example, let's say we want to know how many questions there are for each value of the `value` property. We can do this by adding the `groupBy` argument to the query:

```graphql
{
  Aggregate {
    Question (groupBy: ["value"]) {
      groupedBy {
        value
      }
      meta {
        count
      }
    }
  }
}
```

What do you expect to see here? How will the results differ, now that we've added the `groupBy` argument?

:::note Try it out yourself!
SOME WAY OF TRYING THIS OUT
:::

<details>
  <summary><i class="fa-solid fa-radar"></i> See the JSON response</summary>

```json
{
  "data": {
    "Aggregate": {
      "Question": [
        {
          "groupedBy": {
            "value": "400"
          },
          "meta": {
            "count": 1891
          }
        },
        {
          "groupedBy": {
            "value": "200"
          },
          "meta": {
            "count": 1622
          }
        },
        {
          "groupedBy": {
            "value": "800"
          },
          "meta": {
...
      ]
    }
  }
}
```

</details>

### <i class="fa-solid fa-chalkboard"></i>&nbsp;&nbsp;`groupBy` + `groupedBy`

Results identified by an `Aggregate` query can be further grouped by using a `groupBy` argument. This argument takes a list of properties as an argument, and will group the results by the values of those properties.

This is a particularly useful query pattern for identifying characteristics for subsets of results of a vector search. 

Note that query also included an additional property `groupedBy` under the `Question` class. This property is only available when the `groupBy` argument is used, and its sub-properties can be used to identify the group that the result belongs to.

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;`Aggregate` with `nearText`

We had looked at a few results of a `nearText` query earlier in the earlier section on `Get` queries. We can also use `nearText` in an `Aggregate` query. Take a look:

### <i class="fa-solid fa-code"></i>&nbsp;&nbsp;Example

For example, let's say we are still interested in a similar input text ("Seafaring technology from Scandanavia.") as before, but instead of individual queries, we would like to know how many questions might be related to this query.

We can do this by introducing the `nearText` argument:

```graphql
{
  Aggregate {
    Question (
        nearText: {
          concepts: ["Seafaring technology from Scandanavia."],
          distance: 0.2
        }
      ) {
      meta {
        count
      }
    }
  }
}
```

How do you expect the results to be aggregated? Also, how would the results change as the `distance` parameter changes?

:::note Try it out yourself!
SOME WAY OF TRYING THIS OUT
:::

<details>
  <summary><i class="fa-solid fa-radar"></i> See the JSON response</summary>

  JSON RESPONSE GOES HERE

</details>

Notice we introduce the `distance` argument to limit the search space. This threshold limits the returned results to those that are relevant to the input. Without it, the search results would potentially include the entire class.

By performing a vector search with a distance threshold, we are able to aggregate information only from the questions that are relevant to the input text.

### <i class="fa-solid fa-chalkboard"></i>&nbsp;&nbsp;Limit search space

In order to produce meaningful aggregations with a vector search, you must limit the search space.

This is different from aggregations in lexical searches, such as those often carried out in relational database. In a relational database, grouping or aggregating data can be done using `groupby` with functions such as SUM, AVG, MIN, MAX, etc. This allows you to find a result set and then aggregate the results.

However, a vector search will return all results as it retrieve results based on *degrees* of similarity. As such, a vector search in itself does not exclude any results from the dataset. Accordingly, an aggregation of a vector search result set will include all results, regardless of the certainty of the match.

Accordingly, the search space must be limited so that only relevant results are included in the aggregation. This can be done by setting an explicit `objectLimit` or a `certainty` in the query.

<Quiz questions={varName} />

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;Sub-properties for `Aggregate`

As we have seen, the `meta` property is available for all data types, and can be used with the `count` sub-property to return the number of retrieved objects.

In addition to this, there are a number of other sub-properties that can be used with `Aggregate` queries. Their availability, however, depend on the data type that is being queried.

Let's take a look at some of these sub-properties, based on the `Question` class. 

### <i class="fa-solid fa-code"></i>&nbsp;&nbsp;Example

Try the following query:

```graphql
{
  Aggregate {
    Question (
      nearText: {
        concepts: ["Seafaring technology from Scandanavia."],
        distance: 0.2
      }   
      ) {
      meta {
        count
      }
      answer {
        type
        topOccurrences {
          value
          occurs
        }
      }
    }
  }
}
```

Take a note of the requested properties in the GraphQL query, and consider what types of values they might return. How might these properties change according to the nature of the source data?

:::note Try it out yourself!
SOME WAY OF TRYING THIS OUT
:::

<details>
  <summary><i class="fa-solid fa-radar"></i> See the JSON response</summary>

```json
{
  "data": {
    "Aggregate": {
      "Question": [
        {
          "answer": {
            "topOccurrences": [
              {
                "occurs": 4,
                "value": "Oslo"
              },
              {
                "occurs": 2,
                "value": "Baltic Sea"
              },
              {
                "occurs": 2,
                "value": "Danish"
              },
              {
                "occurs": 2,
                "value": "Denmark"
              },
              {
                "occurs": 2,
                "value": "Greenland"
              }
            ],
            "type": "text"
          },
          "meta": {
            "count": 60
          }
        }
      ]
    }
  }
}
```

</details>

### <i class="fa-solid fa-chalkboard"></i>&nbsp;&nbsp;Sub-properties for `text` data types

It includes a property (`answer`) of the `text` data type, and a property (`value`) of the `int` data type.

As the name suggests, `text` data types are used to store text. Along with the `string` data type, `text` properties may be queried to retrieve one or more of:

- count
- type
- topOccurrences

So, for example -  will reveal the most common tokens in the `answer` property among the vector results:

<Quiz questions={varName} />

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;Review

:::warning TODO
Video here
:::

### <i class="fa-solid fa-pen-to-square"></i>&nbsp;&nbsp;Review exercise

Can you describe, in your own sentence, XXX?

:::warning TODO
Input box for user to put answer in and get back a similarity score & our definition?
??
:::

### <i class="fa-solid fa-lightbulb-on"></i>&nbsp;&nbsp;Key takeaways

:::info
Add summary
:::

import Quiz from '/src/components/Academy/quiz.js'
const varName = [{
  questionText: 'questionText',
  answerOptions: [
    {
      answerText: 'answerOne',
      isCorrect: false,
      feedback: 'feedbackOne',
    },
    {
      answerText: 'answerTwo',
      isCorrect: false,
      feedback: 'feedbackTwo',
    },
    {
      answerText: 'answerThree',
      isCorrect: false,
      feedback: 'feedbackThree',
    },
  ]
}];